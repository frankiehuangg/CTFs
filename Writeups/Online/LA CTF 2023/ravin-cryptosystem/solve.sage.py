

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_861346721469213227608792923571 = Integer(861346721469213227608792923571); _sage_const_1157379696919172022755244871343 = Integer(1157379696919172022755244871343); _sage_const_375444934674551374382922129125976726571564022585495344128269 = Integer(375444934674551374382922129125976726571564022585495344128269); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_65536 = Integer(65536); _sage_const_25 = Integer(25)#!/usr/bin/sage

p = _sage_const_861346721469213227608792923571 
q = _sage_const_1157379696919172022755244871343 
c = _sage_const_375444934674551374382922129125976726571564022585495344128269 

# a ^ x = b mod m
# x = the power
# a = the integer a
# m = modulo
def sqrts(x, a, m):
	# Check if square root exist, if not return (-1)
	if kronecker(a, m) == -_sage_const_1  : 
		return []
	
	# Find the square root of a modulo m
	s = Zmod(m)(a).sqrt()

	# If x == 2 (the base, since 65536 = 2^16) return the value b, where b^16 = a mod p
	if (x == _sage_const_2 ): 
		return [s, m-s]
	# If x != 2 keep recursive
	else:
		# x//2 -> dnc
		# s -> square root modulo m
		# m-s -> since s^2 mod m === (m-s)^2 mod m
		return sqrts(x//_sage_const_2 , s, m) + sqrts(x//_sage_const_2 , m-s, m)

# We calculate the value of a1, a2 where
# a1 = c^65536 mod p
# a2 = c^65536 mod q
# Then we can find the value m by chinese remainder theorem
# where we can calculate m if we know a1 and a2 by crt because p*q = n
# c = m^65536 mod n

# Since there are multiple possibilities of a1 and a2, we loop the array
a1 = sqrts(_sage_const_65536 , c, p)
a2 = sqrts(_sage_const_65536 , c, q)

print(a1)
print(a2)

for i in a1:
	for j in a2:
		print(int(
			# chinese remainder theorem
			crt(
				[int(i), int(j)], 
				[p, q]
			)).to_bytes(_sage_const_25 , 'big'))

